1、什么是线程？什么是进程？
   进程：进程是程序的一次执行过程，系统运行一个程序就是进程从创建到运行到消亡的过程。
   线程：线程是比进程更小的执行单位，一个进程在执行过程中可以产生多个线程。
   多个线程共享进程的内存和资源。
2、线程和进程的关系？线程和进程的特点？
    线程是比进程更小的执行单位，一个进程在执行过程中可以产生多个线程。
    多个线程共享进程的堆内存和方法区资源等，每个线程有独立的虚拟机栈、程序计数器和本地方法栈。
    系统创建一个线程和在多个线程中进行切换工作的负担要比进程小。
3、程序计数器为什么是私有的?
程序计数器的作用：
  1、字节码解释器通过改变程序计数器来依次读取指令，从而实现代码流程控制。
  2、多线程下，用于记录当前线程执行的位置，当线程执行回来了知道执行到哪个位置。

4、虚拟机栈和本地方法栈为什么是私有的?
    1、虚拟机栈：每个java方法在执行时会创建一个栈帧，用以存储局部变量表、操作数栈等信息。方法的调用对应一个栈帧在
    虚拟机栈的入栈出栈过程。
    2、本地方法栈：与虚拟机栈类似。区别是用在native方法上。
    为了保证线程中的局部变量不变其他线程访问到，所以必须私有。
5、并发和并行区别
    并发：同一个时间段，多个任务都在执行。（单位时间内不一定同时执行）
    并行：单位时间内，多个任务同时执行。
6、为什么要使用多线程？
    从计算机来说：线程是程序执行的最小单位，线程的创建和切换的成本都大大小于进程。多核CPU时代意味着多个线程可以同时执行。
    可以减少上下文切换的成本，大大提高了计算机程序的执行效率。
    发展：现在的系统动不动就要求百万千万级的并发，单线程是无法支持的。使用多线程可以大大的支持系统的高并发。
7、使用多线程可能带来什么问题？
    多线程可能导致内存泄露，死锁，线程不安全等问题。
8、线程的生命周期和状态？
    线程的状态：
    new:新建状态，没有调用start()
    runable:运行状态（包含就绪和运行中）
    blocked:线程阻塞于锁
    waiting:等待状态（需要当前线程中断或者其他线程通知）
    time-waiting:超时中断，指定时间内自己唤醒。
    terminated:终止状态。线程执行完毕。
    线程刚创建完成状态是new，调用了start()进行可运行状态，抢到cpu时间片以后进行运行中状态，调用wait()方法，进行等待
    状态，调用sleep和wait（）传时间的方法，进行超时中断状态，指定时间内自动唤醒，唤醒后进入可运行状态，拿到CPU时间片，继续
    进入运行中状态，执行同步方法时，再没有获取到锁时进入blocked状态，拿到锁执行完成，释放锁，最后执行完毕进入终止状态。
9、什么是上下文切换？
    线程在执行过程中会有自己的状态和信息，比如程序计数器，栈等信息，在出现以下情况时需要让出CPU:
    1、调用了sleep wait 2、被锁阻塞 3、时间片用完 4、线程终止
    需要保存这个线程的上下文，以备下次拿到CPU时使用，并加载下一个线程的上下文，就是上下文切换。
10、什么是线程死锁？
    多个线程被阻塞，他们中的一个或者多个在尝试获取被对方占用未被释放的资源，导致线程无限期等待。
    线程产生死锁的4个条件：
    1、互斥条件：该资源任一时刻只能由一个线程占用
    2、请求和保持：线程在请求一个资源时，不放弃自己已经占用的资源
    3、不剥夺条件：线程在使用完资源前，不能被其他线程强制剥夺资源
    4、循环等待：若干个线程形成了头尾相连的循环等待关系。

11、如何预防和避免线程死锁？
    1、获取不到资源时，则释放自己占用的资源
    2、一次性申请所有资源
    3、按序申请资源，按倒序释放资源。

    
12、sleep和wait的区别与共同点？
    区别：
    sleep()不释放锁，wait会释放锁。
    wait不带超时时间不会自动唤醒，需要其他线程调用notify或者notifyAll才会唤醒。
    wait带超时时间的到时间会自动唤醒。
    sleep到时间会结束睡眠。
    wait常用于线程间通信，sleep用于暂停线程。

13、调用start()和run()的区别？
    一个线程刚创建的状态叫做新建，调用start()后线程进入就绪状态，在争抢到cpu时间片后
    才会真正的去执行run方法。
    如果直接调用run，并不是多线程的方式，只是通过main方法调用了一下。

14、synchronized关键字了解
    synchronized关键字用于解决多个线程间访问同一资源的同步性，其保证了被他修饰的代码块和方法在任意时刻只有
    一个线程访问。
    早期的synchronized属于重量级锁，效率不高，因为synchronized的原理是监视器，监视器依赖底层操作系统的互斥
    锁实现，JAVA的线程又是映射到系统底层的原生线程上。如果要挂起或者唤醒一个线程，都需要操作系统帮忙，操作系统
    实现线程之间的切换需要从用户态转换到内核态，这个状态的转换的时间成本较高。
    JDK1.6以后，synchronized做了很多优化，自旋锁、锁粗化，轻量级锁，偏向锁，锁消除等，使得性能得到较大提升。
15、synchronized的使用？
    修饰实例方法：加锁对象是实例对象
    修饰静态方法：加锁对象是当前类
    修饰代码块：加锁对象就是()里面的对象。注意尽量不要用string,因为有字符串常量池
16、synchronized的原理？
    1、修饰代码块：syncronized修饰代码块，实际是在同步代码块的前后分别增加了monitorenter和moniterexit.命令，
    在执行代码块前，会先尝试获取对象的锁，如果锁的计数器是0，则可以抢占锁，获取后计数加1.
    在执行完成后，锁的拥有者可以通过monitorexit去释放锁，将锁的计数器-1变成0、
    2、修饰方法：synchronized修饰方法，是在方法上加了acc_synchronized标记是否是一个同步方法，本质还是基于monitor。
    如果是实例方法：会去尝试获取对象锁。
    如果是静态方法：会去尝试获取类锁
    来实现的。
17、JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗
    偏向锁：偏向锁是针对一个线程，获取锁以后不再有解锁的操作，可以省去很多开销。如果有两个线程来竞争该锁，偏向锁失效
    升级为轻量级锁。偏向锁的加锁方式：cas设置markword中的线程id为自己的线程id,成功则加锁成功。
    轻量级锁：轻量级锁是偏向锁升级后的锁，一个线程想要获取轻量级锁，会先通过cas尝试将加锁对象的markword指向当前栈帧，
    如果成功，则加锁成功。如果失败，判断markword是不是已经指向当前线程，如果是，说明已经获得锁。如果不是则说明有线程在竞争。
    那就进行自旋状态尝试去获取锁，自旋到达一次次数获取不到锁就认为竞争太激烈，升级为重量级锁。
    重量级锁使用操作系统互斥锁实现，他与轻量级锁的区别是不在有自旋，没获取到锁就进入阻塞状态，不消耗cpu，
    等待拥有锁的线程释放锁后，唤醒其他阻塞线程，再次竞争。


18、synchronized 和 ReentrantLock 的区别
    相同点：都是可重入锁，都属于独占锁的实现。
    区别：1、synchronized依赖于jvm，很多优化都没有暴露出来 
          ReentrantLock依赖于api，可以直接查看源码
         2、ReentrantLock增加了高级功能：等待可中断，公平锁，基于Condition实现有选择性的通知。
19、CPU 缓存模型
  CPU cache的工作方式：先复制一份数据放到cpu cache，当需要操作数据的时候从cpu cache拿数据，处理后的数据直接写回
  mainmemory.
20、JVM内存模型
 在JAVA的内存模型中，线程把变量保存到本地内存中，而不是直接从主存读写，就有可能出现一个线程修改了主存中值，另一个线程
 还在使用原始的拷贝。
 因此就需要voliate关键字来修饰变量，让线程每次都直接从主存中读写。
 voliate作用：1、变量的可见性 2、禁止重排序
21、 并发编程的三个重要特性
  1、原子性：一个或者多个操作，要么全部成功，要么全部失败。synchronized具有原子性，voliate不具有。
  2、可见性：当一个线程对共享变量进行修改后，其他线程可以立马看到。synchronized和voliate都具有
  3、有序性：因为有编译器和jvm优化，代码真实的执行顺序可能不是代码编写的顺序。voliate可以禁止指令重排序。
22、synchronized 关键字和 volatile 关键字的区别
    1、volatile只能用于变量，synchronized可以修饰代码块，方法
    2、volatile有可见性和有序性 synchronized有原子性和可见性
    3、volatile关键字主要解决变量在多个线程间的可见性 synchronized解决资源在多个线程间同一时刻只能有一个线程访问。
23、ThreadLocal的作用
   存储线程私有数据，避免线程安全问题。两个线程间ThreadLocal的数据互相不可见。避免线程竞争
24、ThreadLocal原理解析
    thread里有一个ThreadLocalMap ，可以是threadLocal value是要存储的对象value.
    ThreadLocal类可以通过Thread.currentThread获取当前线程，在通过getMap获取当前线程的ThreadLocalMap.
25、ThreadLocal 内存泄露问题
    ThreadLocalMap的key ThreadLocal是弱引用，value是强引用，在ThreadLocal如果没有被外部强引用，在GC的时候key就会
    被清理，但是Value不会，这样就会导致出现一个key为null，value有值的entry，假如不做任何措施，value永远无法清理，导致内存泄露。
    ThreadLocalMap已经考虑到这点，在调用set get remove 都会去清理null key，最后手动去清理下。

26、为什么要使用线程池？
    降低资源损耗，提高资源利用率：重复利用已经创建的线程池降低资源损耗，提高资源利用率
    提高响应速度：当任务过来的时候，不需要再去创建线程可以直接使用线程的。
    提高线程的可管理性：使用线程池可以进行统一的资源分配、监控、调优，


27、 实现 Runnable 接口和 Callable 接口的区别
    1、Runnable 不会返回结果和抛出异常
    2、Callable 会返回结果和抛出异常
28、执行 execute()方法和 submit()方法的区别是什么呢？
    1、execute用于提交没有返回值的任务，无法判断是否成功被线程池执行。
    2、submit用于提交有返回值的任务，线程池会立即返回一个future对象，通过future可以获知任务是否完成，获取任务的结果。
29、创建线程池的方式？
    1、ThreadPoolExecutor通过构造方式创建线程池
    2、通过工具类Executors来创建线程池。
    通过ThreadPoolExecutor构造方式创建线程池的方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险
30、线程池构造参数分析？
    ThreadPoolExecutor的参数如下：
    corePoolSize：定义最小可以同时运行的线程数
    maximumPoolSize：最大线程数
    workQueue：当新任务来会判断当前运行线程数是否到达corePoolSize,如果达到，新任务就被放入队列等待。

    keepAliveTime：核心线程数以外的线程在等待一段时间后没有任务进来就会销毁。
    unit：keepAliveTime时间单位
    threadFactory：线程工厂
    handler：拒绝策略

    拒绝策略：
     1、抛出异常
     2、直接丢弃
     3、丢弃最早的未处理请求
     4、直接由提交任务的线程运行任务。

31、线程池原理解析
    提交任务，先判断线程数是否已达到核心线程数，如果未到则创建线程运行。
    如果达到了，则判断等待队列是否已满，如果未满，则加入等待队列。
    如果已满，判断线程池是否已经达到最大线程数，如果未到，则创建线程运行。
    如果已到，则执行拒绝策略。

32、AtomicInteger是什么？实现原理
    整型原子类。
    用cas(compare and set ) 和 voliate用来保证整型操作的原子性，
    cas是用期望的值和原本的值做比较，如果相同则更新。

33、AQS是什么？原理解析
    AQS的核心思想是，如果请求的资源空闲，则将请求资源的线程设置为工作线程，并且设置资源的状态为锁定。
    如果请求的资源被锁定，则将请求资源的线程放入一个等待队列中阻塞等待被唤醒抢占资源。
    AQS将每个请求共享资源的线程封装成一个先进先出的锁队列中的一个节点来实现锁的分配。
    使用一个int的变量来表示资源同步状态，通过内置的先进先出队列实现线程的排队，使用cas修改资源同步状态来
    实现获取资源的目的。
34、AQS 对资源的共享方式有哪些？对应的组件有哪些
    独占式：对于一个资源任意时刻只能由一个线程执行 ReentrantLock
    共享式：对于一个资源一个时刻可以由多个线程同时执行 CycleBarrier CountdownLatch。

35、AQS组件总结和使用场景
信号量：同一时刻可以指定多个线程访问资源。用以资源有明确梳理限制的场景，比如限流、停车场，数据库连接池
CountDownLatch:线程协调同步器。用以控制线程等待，直到计数器为0，才执行下面的逻辑。 比赛，所有运动员都比完赛，出了分数，才会出排名。
CycleBarrier:当一组线程到达一个同步点后阻塞，直到全部线程都达到这个阻塞点，再打开屏障。  比赛，等待所有运动员都达到场地就绪，才会开跑。
36、CountDownLatch和CycleBarrier的区别
CountDownLatch：不能循环使用
CycleBarrier：可以循环使用

CountDownLatch：一个或者n个线程，等待其他多个线程执行完成才开始执行。
CycleBarrier：n个线程互相等待都到达同步点后才开始执行。

37、shutdown()VSshutdownNow()
shutdown：关闭线程池，并且设置线程池状态为SHUTDOWN,不再接收新任务，已在队列里的任务会执行完成。
shutdownNow：关闭线程池，并且设置线程池状态为STOP,不再接收新任务，停止正在运行的任务，取消已在队列里的任务。
38、isTerminated() VS isShutdown()
isTerminated：当调用 shutdown() 方法后返回为 true。
isShutdown：当调用shutdown 并且所有任务都执行完毕返回true
39、线程池大小确定
线程池太小的问题：
在任务激增的时候任务处理不完，进入等待队列，超出的任务走拒绝策略，会造成任务丢失，也可能会内存溢出，cpu利用率不高。
线程池太大的问题：
线程数太大，会导致大量线程在抢占cpu，有频繁的上下文切换，资源消耗的厉害，效率不高。

IO密集型可以设置为2N,
CPU密集型可以设置为N+1.


40、线程池在实际项目的使用场景
    导入导出。

41、怎么监测线程池运行状态
 SpringBoot 中的 Actuator 组件。
 ThreadPoolExecutor提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。

42、线程池使用注意事项
    1、需要根据机器实际的情况，实际的应用场景，使用构造方法创建线程池 。
    2、需要监控线程池运行状态。
    3、不同类别的业务用不同的线程池。不同的场景对线程资源的使用不同
    4、正确配置线程池参数
    5、给线程池命名
43、ThreadLocal数据结构
    Thread中有ThreadLocalMap，key是ThreadLocal对象，value是要存储的对象值。
    ThreadLocalMap没有链表结构，
44、ThreadLocal如何解决hash冲突。
    如果计算hash得到该值应该放到槽位1，但是1上又entry，那就往后找，找到第一个entry为null的槽位，将该值放入。
45、ThreadLocalMap的两种过期key数据清理方式
    rehash中会进行一轮探测式清理，从开始位置遍历数组，将过期的entry设置为null，过期就是key=null,将遍历途中未过期的数据
    重新hash后找到定位的位置，如果有entry，则往后放到就近一个空的entry上。碰到空槽位后结束探测


    启发式清理：就是从hashcode定位的位置开始清理。
    
46、ThreadLocal扩容
    在set数据完成后，进行一次启发式清理，若没有清理到数据且entry数量达到列表的扩容阈值，
    则开始rehash.
    rehash先进行一次探测式清理，清理完如果size达到扩容阈值的3/4则进行扩容。
    扩容为原来的2倍，所以的entry重新hash到对应位置，有数据则往后就近放入空entry上、
47、父子线程共享InheritableThreadLocal
    子线程在父线程中通过new Thread创建，在new Thread的init方法中拷贝了父线程的ThreadLocal。
    因为这个父子线程共享基于new Thread来实现，线程池中线程是复用的，所以会存在问题。
48、ThreadLocal使用场景  InheritableThreadLocal 使用场景
    数据库连接 session管理  user  全局请求id    InheritableThreadLocal 全局请求id. 在接口里异步处理的情况。
49、并发容器原理CopyOnWriteArrayList 
    读没有任何控制，因为底层的array不会改变，每次修改和新增都会创建一个新数组，不影响原来的数组。
    写操作加锁，创建一个新数组来实现，操作完毕后将list底层array指向新数组。
    使用于少写多读的场景 黑名单 白名单 
    缺点：内存浪费、保证最终一致性，无法保证读的实时一致。
50、BlockingQueue原理
    BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。  
51、CAS ABA 问题
    CAS就是拿期望值与原值做比较，如果想等，认为之前没有更新后可更新，否则不更新。
    ABA问题：年初0元，一年挣了300W ，买了个房子，年末0元。虽然看起来没有变化，其实挣了钱了还得缴税
52、基本数据类型原子类的优缺点
    1、cas适合低并发，高并发情况下自旋多，CPU消耗高
    2、cas保证单个变量原子性，多个变量同时保证原子性无法保证。
    


