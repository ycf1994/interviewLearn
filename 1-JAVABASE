1、为何说JAVA只有值传递？
JAVA中将实参传递给方法的方式是值传递：
1.1如果参数是基本数据类型，传递的就是字面值的拷贝。
1.2如果参数是引用数据类型，传递的是参数所引用的对象所在的地址值的拷贝。
2、什么是字节码？采用字节码有什么好处？
 在java中，java原代码通过javac命令编译后得到的.class文件就是字节码，他只面向于虚拟机。
 好处：
 1、只面向于虚拟机，而不针对与特定机器，可以做到一次编译，处处运行。
 2、字节码拥有比传统解释性语言更高的执行效率（JVM还可以基于jit编译器将热点代码进行缓存，即字节码与机器码对应关系的缓存，加快执行效率），还拥有解释性语言灵活的可移植性。
3、为什么说 Java 语言“编译与解释并存”？
   java源文件先通过编译器编译成.class字节码文件，在通过jvm的解释器，将字节码解释成对应机器码来执行，所以说JAVA语言是编译与解释并存的。
4、静态方法为什么不能调用非静态成员?
 1、静态方法是属于类的组成部分，在类加载的时候就会分配内存，可以通过类名.方法和 对象.方法去执行。非静态成员属于实例对象的，需要在实例化对象之后才会存在。
 2、因这两个的生命周期不一致，静态方法的生命周期包含了非静态成员，即有可能静态方法已存在，而非静态成员还不存在的情况，因此JVM规定静态方法去调用非静态成员是非法的。
5、== 和 equals的区别
  1、== 用在基本数据类型中比较的是值。
     == 用在引用类型中比较的是对象的地址。
  2、基本数据类型没有equals
     引用数据类型，如果没有重写Object的equals，那就和==一样，比较对象地址。
     如果重写了equals，一般是比较对象中各个属性值，比如String的equals。
6、为什么重写了equals还要重写hashcode
   因为两个想等的对象的hashcode必须是一样的。也就是说通过equals来判断对象相同了，那么他的hashcode必然是一致的。
   如果重新了equals但没有重写hashcode，就会造成两个想等的对象有不痛的hashcode，在hashset中就会出现重复元素的存在。违背了这两个方法的设计初衷、
7、hashcode是什么有什么用？
   hashcode是哈希表的散列码，Object中的hashcode是一个native方法，将对象的地址值转换成一个整数。
   在hashset中，会计算要加入的对象的hashcode的位置，与其已存在的hashcode进行比较，如果没有相同hashcode，那就认为无重复。如果存在，那就在用equals比较。减少了equals的次数，提高了效率

8、为什么要提供hashcode
   目的是提高对象比较的效率，缩小比较成本。
9、自动装箱和拆箱是什么？原理是什么？
   装箱就是将基本数据类型用其对应的包装引用类型来包装起来。
   拆箱就是将包装类型转换成基本数据类型。

   以 int Integer举例
   装箱的原理：Integer.valueOf
   拆线 ：int.intValue();
10、面向对象和面向过程的区别？
    面向对象和面向过程的区别主要在于解决问题的形式不同：
    面向对象：将问题细化抽象出一个个的对象，在基于对象来调用方法来解决问题。
    面向过程：将问题细化为一个个方法去执行来解决问题。
11、成员变量和局部变量区别？
    语法：成员变量可以用private public static transit volite 等修饰符修饰
          局部变量没有private 这些修饰符，可以用final
     存储：成员变量存在堆内存中，局部变量在栈内存中
     生命周期：类成员变量在类加载的时候存在，在类卸载的时候消亡。
              实例成员变量在对象实例化后存在，在对象回收销毁后消亡
              局部变量只在方法执行时存在。
     默认值：成员变量没有显示设置会有默认值，局部变量没有默认值。
12、面向对象的三大基本特征
    封装：封装就是将对象的属性隐藏在对象内部，不允许外部直接访问，但是提供一些公开的方法让外部访问属性。
    继承：继承是使用已存在的类作为基类来快速创建新类，新类会全部继承父类的所有，并且可以增加新的数据和功能。
    多态：一个对象可以有多种状态，确切的说是父类引用可以指向子类实例。
13、接口和抽象类的共同点与区别
    共同点：
    1、都不能实例化
    2、都可以有抽象方法
    3、都可以有默认实现的方法
    区别：
    1、接口主要对类的行为进行约束，实现接口就具有对应的行为。抽象类主要用作代码复用，强调父子所属关系。
    2、接口里的成员变量都是public static final .抽象类中的成员变量默认是default修饰
    3、一个类只能继承1个类，可以实现多个接口
14、String、StringBuffer、StringBuilder 的区别？
 可变性：String使用一个私有的字符数组保存数据，且没有提供给外部操作数组的方法，并且String是final的，无法被继承，因此final是不可变的。
     Stringbuffer和StringBuilder都继承自己AbstractStringBuilder，在这个父类里也是通过字符数组来保存数据，还提供了很多改变字符数组的方法，
     因此StringBuffer/StringBuilder是可变的。
 线程安全性：String不可变，所以是线程安全的。StringBuffer的修改字符数组的方法都加了同步锁，所以也是线程安全的。StringBuilder是线程不安全的。
 性能：String的字符串连接是基于StringBuilder来实现的，每次都会创建一个新的对象，并且将引用指向新的String对象。因此在大量字符串连接时性能很差。
 StringBuilder和StringBuffer都不会创建新的对象，不浪费内存，在多线程下，使用StringBuffer，不需要考虑线程安全的场景使用StringBuilder效率更高
15、为什么说String是不可变的？
    1、String维护了一个私有且final的char数组来保存数据，并且没有对外提供修改数据的方法
    2、String类是final修饰的，无法被继承，杜绝了通过子类来修改数据的方式。
    因此String是不可变的。
16、字符串常量池的作用？
    声明一个字面值常量时，会先去常量池里找，如果找到，即关联该引用，找不到，则创建。
    作用：1、提升字符串性能 2、避免了字符串重复创建，减少空间浪费，
17、JAVA泛型是什么？什么是类型擦除？项目中哪些地方用到了泛型？
    泛型是什么：
    泛型的本质是参数化类型，即需要操作的数据类型被指定为一个参数。
    泛型提供了编译时的类型检查机制，该机制方便程序在编译时检查到非法的类型。
    类型擦除：java的泛型是伪泛型，在运行时会类型擦除，验证方式，通过反射去调用方法传入不符合泛型类型的数据，可以调用成功。
    使用场景：
    定义接口通用返回结果
    定义Excel表格解析类型
    集合操作

18、反射是什么？反射的优缺点？
     反射赋予了在程序运行过程中分析类，执行类方法、对象方法的功能。
     通过反射可以任意获取到类的属性方法等，并且可以随意调用里面的方法。

     优点：让代码更加灵活，为框架的开发运用提供了便利。
     缺点：
     任意的获取调用容易造成安全问题：访问到私有的数据并修改在有些情况是不可接受的，无视泛型的类型检查。
     反射性能差。（动态解析，需要去发现方法、属性，参数需要装箱拆箱，打包成数组）
19、反射的使用场景？
    框架的应用：动态代理，spring的ioc等
20、注解是什么？注解的本质？
    注解是JDK5引入的新特性，用来修饰类、变量、方法等。
    注解的本质是继承了Annotation的接口。
21、注解的解析方式有哪些？
    1、编译期：编译时扫描注解并处理，比如override编译时检查该方法是否重写父类的方法。
    2、运行期：在运行时扫描处理，如果@Autowire 在运行时注入对象。

22、所有异常的共同父类是什么？Exception和Error的区别？
   java.lang.Throwable
   Expection:程序可以处理的异常，可以通过catch捕获处理。分为运行时和检查时异常
   Error:程序无法处理的异常，没有捕获。比如OOM
23、检查时异常和运行时异常区别和举例？
    检查时异常：在编译时期就会检查，没有try catch 或者throw就检查不通过，不能完成编译。
    运行时异常：可以正常编译，运行时才有可能抛出的，比如空指针，下标越界等
24、try catch finally 的使用与注意事项
    try:用于捕获异常，其后可以跟0个或多个catch块，如果没有catch则必须有finally
    catch:用于处理捕获的异常
    finally:无论是否捕获到异常，finally都必然被执行。
25、从字节码角度分析try catch finally这个语法糖背后的实现原理。
Java 采用方式是复制 finally 代码块的内容，
分别放在 try catch 代码块所有正常 return 和 异常 throw 之前。所以finally 代码块始终会执行。
26、finally一定会执行吗？
 不一定。
 1、System.exit();
 2、程序所在线程死亡
 3、宕机
27、什么是序列化与反序列化？为什么要序列化
    序列化：将数据结构或者对象转化成二进制流
    反序列化：将序列化得到的二进制流转化成数据结构和对象

    序列化的目的是通过网络传输对象或者将对象数据存储到数据库或者文件中去。
28、有了字节流为什么还要字符流？
    如果没有字符流，那就需要通过字节流转换成字符流，会更加耗时，且如果不知道编码类型会出现乱码。
29、什么是代理模式？
    使用代理对象来替代目标对象的方式，可以在不修改原对象的前提下，提供额外的功能，扩展需要的功能。
    目的是扩展目标对象的功能，比如在方法调用前后增加操作。
30、静态代理和动态代理的区别？
    静态代理：
    1、定义接口和其实现类
    2、定义一个代理类实现上述接口
    3、在代理类中注入目标对象，在代理类的方法里调用对应目标对象的方法，以实现功能的扩展。
    静态代理：需要给每一个类的方法写对应的增强代码，非常不灵活。

    动态代理：不需要给每个类都创建代理类，写对应增强代码即可实现增强。从JVM角度来说是动态生成类字节码并加载到JVM中。

31、动态代理有哪些方式？有哪些优缺点？
    1、JDK动态代理。
       1、定义接口和其实现类
       2、自定义InvocationHandler实现InvocationHandler接口，实现接口的invoke方法，该方法就是去调用目标对象的实际方法，并自定义处理逻辑
       3、通过 Proxy.newProxyInstance来创建代理对象
    2、CGLIB代理。
       1、定义目标类
       2、自定义MethodInterceptor实现MethodInterceptor接口，实现接口的interceptor接口，类似jdk代理的invoke，在这个方法里做目标对象方法调用，并自定义处理逻辑
       3、通过Enhancer.crate创建代理类


       JDK代理必须是实现了接口的类或者直接代理接口。原理的接口的实现类。
       CGLIB可以代理类，原理的通过类的子类重写父类的方法来实现增强。要求类和方法不能是final，不然无法继承和重写。
       JDK代理效率更高。
32、常见的IO模型有哪些？
    BIO:同步阻塞IO，应用程序发起read调用后，会一直阻塞，直到内核将数据拷贝到用户空间。客户端连接数少的情况适用。
    NIO:多路复用的IO，首先发起select调用，询问内核数据是否已经准备好。等内核数据准备好了，线程再发起read调用，read的过程还是阻塞的。
         有selector的概念，只要一个线程就可以管理多个客户端。
    AIO: 异步IO模型，基于事件和回调机制实现。应用调用之后不会阻塞。当后台处理完成，通知对应线程处理。

33、为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？
     计算机是二进制的，计算一个数字时，空间是有限的，无限循环的小数在存储时会被截断导致精度丢失。
34、BigDecimal的大小比较判断方式？
     compareTo
35、BigDecimal 的使用注意事项
    用compareTo比较大小
    我们在使用 BigDecimal 时，为了防止精度丢失，
    推荐使用它的BigDecimal(String val)构造方法或者 BigDecimal.valueOf(double val) 静态方法来创建对象。


36、list、set、queue、map区别
37、ArrayList和LinkedList 的区别
38、comparable 和 Comparator 的区别
39、HashMap与HashTable区别
40、HashSet如何检查重复？
41、HashMap实现原理？
42、HashMap 的长度为什么是 2 的幂次方
43、HashMap 多线程操作导致死循环问题
44、ConcurrentHashMap 和 Hashtable 的区别
45、ConcurrentHashMap 线程安全的具体实现方式/底层具体实现
46、ArrayList和HashMap扩容
