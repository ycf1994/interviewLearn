1、JAVA运行时数据区
    程序计数器：
    线程私有。
    作用：1、字节码解释器通过改变程序计数器依次读取指令来实现代码的流程控制 2、多线程情况下，用来记录当前线程
    执行的现场用以线程重新获取到CPU时恢复现场。
    不会OutOfMemory
    JAVA虚拟机栈：
    线程私有，生命周期同线程。由一个个栈帧组成，栈帧中存放局部变量表、操作数栈、方法出口、动态链接等。
    一个方法的执行对应虚拟机栈中一个栈的入栈与出栈。
    StackOverFlowError：当请求的栈的深度大于虚拟机栈的最大深度时报错。
    OutOfmEMORT：当无法申请到足够的空间时报错。

    本地方法栈：线程私有，用于native方法
    堆：
    线程共享，用于存放对象实例。JDK1.7开启了逃逸分析，如果方法中的对象实例没有返回，没有被外部引用，允许在栈上分配。
    方法区：
    线程共享，存放类信息，常量、静态变量。
    JDK1.8开始元空间，直接使用直接内存。
    运行时常量池：
    存放编译器生成的各种字面值，符号引用等。
    直接内存：
    非虚拟机的内存区域，nio引入基于通道、缓冲区的io方法，可以通过native方法分配堆外内存，在通过directbuffer来
    操作。提高性能，比较java和native的来回复制。

2、JAVA对象创建过程
    JAVA对象的创建过程：
    类加载检查-分配内存-初始化零值-设置对象头-执行init方法
    类加载检查：虚拟机接收到new指令，先判断类是否加载、解析、初始化过，如果没有，执行相应的类加载过程
    分配内存：为对象分配内存：1、指针碰撞，用于规整的内存，分界指针的两边分别是已使用和未使用的内存，将指针向
    未使用内存方法移动需要分配的内存大小来分配 2、空闲列表 虚拟机维护一个空闲的内存列表，根据对象需要的内存大小
    来分配。
    内存分配并发：1、cas乐观锁+自旋分配 2、TLAB,虚拟机为线程预先分配内存，提供给该线程创建对象
    初始化零值：初始化默认值
    设置对象头：存储对象头，类信息、锁信息、哈希code，分带年龄等
    执行init方法：执行代码写的初始化


3、对象的访问定位
    1、句柄：在内存中划分一个区域作为句柄值，栈中的引用指向句柄，句柄指向了类型与实例数据地址
    2、直接引用：引用指向对象本身 hotspot使用这个
4、String类和常量池
    对于编译器可以确定的字符串，直接存入字符串常量池。（1、直接字面值 2、两个字面值 连接  3、两个final常量连接）


5、如何判断对象是否死亡（两种方法）。
6、简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
7、如何判断一个常量是废弃常量
8、如何判断一个类是无用的类
9、垃圾收集有哪些算法，各自的特点？
10、HotSpot 为什么要分为新生代和老年代？
11、常见的垃圾回收器有哪些？
12、介绍一下 CMS,G1 收集器。
13、Minor Gc 和 Full GC 有什么不同呢？
14、分代回收解释
15、重要的JVM参数
16、类的生命周期和加载过程
17、双亲委派是什么？
18、双亲委派的好处？
19、如何打破双亲委派？
20、如何自定义类加载器？
21、JVM调优？
22、JDK常用命令和可视化工具？

