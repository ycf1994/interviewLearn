1、JAVA运行时数据区
    程序计数器：
    线程私有。
    作用：1、字节码解释器通过改变程序计数器依次读取指令来实现代码的流程控制 2、多线程情况下，用来记录当前线程
    执行的现场用以线程重新获取到CPU时恢复现场。
    不会OutOfMemory
    JAVA虚拟机栈：
    线程私有，生命周期同线程。由一个个栈帧组成，栈帧中存放局部变量表、操作数栈、方法出口、动态链接等。
    一个方法的执行对应虚拟机栈中一个栈的入栈与出栈。
    StackOverFlowError：当请求的栈的深度大于虚拟机栈的最大深度时报错。
    OutOfmEMORT：当无法申请到足够的空间时报错。

    本地方法栈：线程私有，用于native方法
    堆：
    线程共享，用于存放对象实例。JDK1.7开启了逃逸分析，如果方法中的对象实例没有返回，没有被外部引用，允许在栈上分配。
    方法区：
    线程共享，存放类信息，常量、静态变量。
    JDK1.8开始元空间，直接使用直接内存。
    运行时常量池：
    存放编译器生成的各种字面值，符号引用等。
    直接内存：
    非虚拟机的内存区域，nio引入基于通道、缓冲区的io方法，可以通过native方法分配堆外内存，在通过directbuffer来
    操作。提高性能，比较java和native的来回复制。

2、JAVA对象创建过程
    JAVA对象的创建过程：
    类加载检查-分配内存-初始化零值-设置对象头-执行init方法
    类加载检查：虚拟机接收到new指令，先判断类是否加载、解析、初始化过，如果没有，执行相应的类加载过程
    分配内存：为对象分配内存：1、指针碰撞，用于规整的内存，分界指针的两边分别是已使用和未使用的内存，将指针向
    未使用内存方法移动需要分配的内存大小来分配 2、空闲列表 虚拟机维护一个空闲的内存列表，根据对象需要的内存大小
    来分配。
    内存分配并发：1、cas乐观锁+自旋分配 2、TLAB,虚拟机为线程预先分配内存，提供给该线程创建对象
    初始化零值：初始化默认值
    设置对象头：存储对象头，类信息、锁信息、哈希code，分带年龄等
    执行init方法：执行代码写的初始化


3、对象的访问定位
    1、句柄：在内存中划分一个区域作为句柄值，栈中的引用指向句柄，句柄指向了类型与实例数据地址
    2、直接引用：引用指向对象本身 hotspot使用这个
4、String类和常量池
    对于编译器可以确定的字符串，直接存入字符串常量池。（1、直接字面值 2、两个字面值 连接  3、两个final常量连接）


5、如何判断对象是否死亡（两种方法）。
    引用计数法：有引用就+1，引用失效就-1，计数为0说明没有地方引用，对象可以回收
    优点：简单、高效
    缺点：无法解决循环依赖

    可达性分析算法：从GC root开始向下搜索，相连的链路称为引用链，当一个对象没有与GC root的引用链相连则可以回收
    GC ROOT :虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区内 静态变量、常量，被同步锁持有的对象

对象可以被回收就一定会回收吗？
不一定，经可达性分析得到的不可达对象在经历标记后还会进行一次筛选，如果没有调用过finalize，那会调用finalize。
在finaliz中可以将对象与GC ROOT关联以达到拯救对象的目的。
如果之前调用过，则会回收。
6、简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
强引用：内存不足，抛出outofmemort异常
软引用：内存不足就会被回收。
弱引用：不管内存是否充足都会回收
虚引用：用来跟踪对象GC的活动
7、如何判断一个常量是废弃常量
  如果字符串常量池存在常量"abc",但是没有一个String对象引用到它，没有一个栈直接引用到它，那就认为已废弃，可以回收。
8、如何判断一个类是无用的类
    该类所有实例已回收
    该类的class对象无引用，无法通过反射访问
    加载该类的classloader被回收
9、垃圾收集有哪些算法，各自的特点
    1、标记清除  标记出所有不需要回收的对象，标记完成后清除未被标记的对象。
       缺点：效率不高 、 空间不规整、GC过程需要暂停整个应用
    2、标记复制  将内存分为相同的两块，每次使用其中的一块。当一块使用完，当其中存活的对象复制到
    另一块，然后将这块全部清理掉。
        优点：简单高效 、空间规整 缺点：空间浪费大、不适用于有较多对象存活的场景
    3、标记整理 将所有存活的对象向一边移动，清理掉边界以外内存。
       优点：内存规整、内存可使用率高  缺点：效率低于复制算法、

10、HotSpot 为什么要分为新生代和老年代？
    因为不同对象的寿命不一样，分为新生代和老年代可以将寿命短的放在新生代，寿命长的放在老年代，
    不同的区使用不同的回收算法，新生代回收频率高点，老年代的频率低点，提高效率。
11、常见的垃圾回收器有哪些？
    parnew+cms  最短回收暂停时间
    新生代用parnew 复制算法，多线程并行收集。
    老年代用cms回收器达到获取最短回收暂停时间的目的。
    cms回收器是真正意义的并发收集器，让用户线程和GC线程同时工作。
    cms是一种标记清除的回收器。
    流程：
    1、初始标记，暂停用户线程，快速标记直接与GC root相连的对象，速度很快。
    2、并发标记：同时开启用户线程和GC线程，标记与GC ROOT引用链相连的对象。
    3、重新标记：标记并发标记过程中因用户线程工作导致的标记变动（原先不可达的，现在可达了），暂停时间比初始标记长
    4、并发清除：开启用户线程，清除被标记的对象。
    优点：并发，回收暂停时间短
    缺点：对CPU资源敏感、无法处理浮动垃圾、产生大量空间碎片。（可以配置一个gc参数在几次GC后进行一次压缩，默认是每次都会压缩）

    Parallel Scavenge 吞吐量
    Parallel Scavenge 新生代复制算法，老年代标记整理算法。
    关注点是吞吐量，即高效利用CPU。吞吐量就是 用户线程时间占总耗时的比重。


13、Minor Gc 和 Full GC 有什么不同呢？
  Minor Gc  新生代GC耗时短，频率高。Full GC老年代GC，耗时长。

  什么时候触发Minor GC?
  当Eden区满触发，将eden中存活对象复制到survivor区内。
  当survivor活动区满触发，将survivor活动区的存活对象复制到另一个区，然后清理此区内存。

  什么时候触发 Full GC?
  老年代空间不足
  方法区空间不足
  Minor GC进入老年代的平均大小大于老年代的可用空间
  创建一个大对象，eden区放不下会直接放入老年代，老年代如果空间不足，就会触发Full GC
    
    
16、类的生命周期和加载过程
    类的生命周期：
    加载-连接（验证-准备-解析）-初始化-使用-卸载

    类的加载过程
    加载-连接（验证-准备-解析）-初始化
    加载：将二进制字节流加载进来，在字节流转换成方法区中的静态数据结构，在内存中生成针对该类的class对象。
    验证：文件格式（是否是CAFEBEBE），元数据验证（语法语义验证），字节码验证（确保程序语义合法，符合逻辑），符号
    引用验证（确保符合能正常解析）
    准备：为类变量分配内存，设置初始值
    解析：将符号引用解析为直接引用
    初始化：执行clinit方法，初始化
17、双亲委派是什么？
    每个类都有一个类加载器加载。加载的时候会遵循双亲委派原则。
    类加载时，首先判断这个类是否加载过，如果加载过，就直接返回。
    如果没有加载时，类加载器会首先委托给父类加载器加载，当父类加载器无法加载时，才有子加载器加载。

18、双亲委派的好处？
    避免类的重复加载，保证java的核心api不被篡改。
    如果不用双亲委派的话，一个java应用中就可能出现多个java.lang.Object，
19、如何打破双亲委派？
    继承ClassLoader，重写loadClass

    tomcat为啥要打破双亲委派？
    因为不同的应用可能有同样的包名同样的类，但是业务不同。如果使用双亲委派，那么可能存在互相覆盖的情况
20、如何自定义类加载器？
    继承CLassLoader，重写findClass

22、JDK常用命令和可视化工具？
  jmap jhat jstack
  JConsole
  visual vm
  

