1、redis的数据结构有哪些？分别阐述

    简单动态字符串SDS：
        结构：free剩余空间 len数据长度 buf char数组 . 
        优势：O(1)复杂度获取字符串长度、杜绝缓冲区溢出（当修改字符串时，会先判断剩余的空间是否满足修改后的字符串，不满足
        活自动扩展空间）、减少修改字符串时带来的内存重分配次数（空间预分配，惰性空间释放）、C语言字符串不能保留空字符串，
    REDIS使用SDS作为字符串表示

    链表：
        链表每个节点的表示 前驱、后继、值。
        链表结构：head头结点 tail尾结点 len长度
        head头结点的prev和tail的next指向null.

    字典：
       哈希表节点：结构：key value next(指向下一个hash表节点)
       哈希表：哈希表数组、数组大小、已有数量
       字典：类型、私有数据（某些类型需要传）、哈希表数组（2个，一般情况只用第一个，第二个在rehash的时候用到）、
       rehash进度（当前rehash的索引值 如果没在rehash那就-1）

    跳跃表：
        跳跃表节点：对象、分数、后退指针、层（前进指针、跨度）
        跳跃表：头节点、尾结点、层数最高节点的层数、节点数量
    
    整数集合：
        整数集合：编码、长度、数组 从小到大排列，不重复
    
    压缩列表：
        压缩列表：总字节数、尾结点距离起始位置的偏移量、压缩列表的节点数量、数据、zlend(特殊值记录压缩列表末尾)
    

    
    对象：
        字符串：
            可以用long类型保存的整数 int
            保存短字符串 embstr  一次性分配连续空间
            保存长字符串 raw 分配两次空间
        列表对象：
            底层可以是压缩列表、链表
            字符串元素长度较小或者列表数据数量较少时是压缩列表。
        哈希对象：
            底层可以是压缩列表，kv前后连续放置。
            底层可以是字典。
            字符串长度较小或者键值对数量较少时使用压缩列表
        集合对象：
            底层可以是整数集合。
            底层可以是字典，k存值 v为null.
            当元素都为整数且较少时使用整数集合。

        有序集合对象：
            底层可以是压缩列表，元素、分数前后连续放置，分数低的靠前。
            底层可以是跳跃表+字典。跳跃表按分值从小到大排列，每个节点保存一个集合元素。
            字典创建了成员到分值的映射。
            为什么要同时用跳跃表和字典，字典用于根据成员快速获取分值，跳跃表用于排序和范围查询。

            元素数量较少使用压缩列表。
    
2、redis和memcache的异同点
    共同点：都是基于内存实现
           都有过期策略
           性能都很高。
    不同点：redis支持丰富的数据类型，memcache只支持最简单的kv
           redis支持数据的持久化，可以将数据持久化到磁盘中，方便恢复使用。而memcache是纯内存的。
           redis在内存使用完时，可以将不用的数据持久化到硬盘中。而mecache会直接报错。
           redis支持集群模式，而memcache不支持原生集群模式，需要客户端来分片。
           redis单线程多路IO复用,memcache是多线程的非阻塞IO
           redis支持事务lua发布订阅
           redis有惰性删除和定期删除，而memcache只支持惰性删除。
3、为什么要用reids?
如上。
4、redis的使用场景？
    缓存、分布式锁、限流、消息订阅、复杂业务（通过bitmap统计活跃用户，通过有序集合来实现排行榜）
5、redis单线程模型详解？
    redis是基于Reactor模式实现的一套高效的文件事件处理器，由于文件事件处理器是单线程的，因此称redis是单线程的。
    redis通过io多路复用程序来监听来自多个客户端的连接，它会将读写等事件注册并监听是否发生，
    好处是不需要创建多个线程来处理客户端的请求，降低了资源的消耗。

6、redis6.0之前为什么不使用多线程？
    单线程编程容易且更易维护。
    redis的性能瓶颈不在cpu，主要在内存和网络。
    多线程可以会存在死锁和频繁的上下文切换，反而会影响到性能。
7、redis6.0之后为什么引入多线程？
    redis6.0引入多线程的目的是提高io性能，redis的多线程只用在读写io等耗时的地方，执行命令还是单线程的。
8、redis设置过期时间有什么用？
    内存有限，所有数据都保存的话，很容易就OOM。
    用于业务，很多场景的数据只要求在某一段时间有效，比如短信验证码/token等。

9、redis如何判断数据是否过期？
redis通过过期字典来维护数据的有效时间。
10、redis过期数据的删除策略有哪些？
    惰性删除：数据过期没有真正删除，在获取时进行判断是否过期。
    定期删除：定时任务定期删除
11、redis的内存淘汰机制？
    从已设置过期时间的数据中，挑选最近最少使用的。
    从已设置过期时间的数据中，挑选快要过期的。
    从已设置过期时间的数据中，随机挑选。
    从所有数据中，挑选最近最少使用的。
    从所有数据中，随机挑选。
    内存不足时报错。
    从已设置过期时间的数据中，挑选最近最不经常使用的。
    从所有数据中，挑选最近最不经常使用的。
12、redis的持久化机制
    1、rdb:创建快照来备份某一个时间点的所有数据。 优点：恢复快 缺点：容易丢失最后一次备份到崩溃这块时间的数据
    2、aof:备份redis执行每一条修改的命令。先把命令写到缓存，在根据配置的规则持久化到磁盘，可以配置成everysec基本没影响
       优点：最多丢失1s数据。缺点：恢复比较慢。
    还有混合持久化，aof重写时将rdb内容写到开头。

13、redis事务的原理
通过MULTI开启事务，输入一系列命令，输入EXE时执行。只是批量执行，如果执行报错也不会中断。
DISCARD来去取消事务。
WATCH一个键，如果在事务中被更改，那么事务不会执行。

14、缓存穿透
    大量请求的key不存在缓存中，直接落到数据库。指key在数据库也不存在
    解决：
    1、基本的key校验，例如id在某个范围内，邮箱、手机号格式校验
    2、缓存无效key：缓存无效key可以应对短时间同一个key的攻击
    3、布隆过滤器：通过布隆过滤器，认为不存在的元素必然不存在。认为存在的元素有极小概率不存在。
15、缓存雪崩
    缓存同一时间大面积失效，导致请求全部落到数据库。
    针对热点缓存：
    1、随机时间失效
    2、永不失效
    针对恢复：
    1、采用集群，避免单机问题
    2、限流返回友好提示。
16、缓存击穿
    缓存中没有但数据库有的数据，并发突然缓存失效，大量针对同一个数据的请求落到数据库。
    1、缓存永不失效
    2、并发读取数据库加互斥锁。
17、缓存与数据库一致性？
    先更新db，在删除缓存
    如果删除缓存失败：
    1、设置缓存较短的过期时间
    2、重试几次，失败的话加入到失败队列，继续重试，重试n次，依旧失败报警。
18、redis主从复制原理
    redis子服务器执行slaveof ip port 成为对应服务器的子服务器。
    会进行一次完整同步，redis主服务器会执行bgsave进行一次rdb备份，并记录从现在开始的写命令到一个缓冲区。
    主服务器将rdb发送给从服务器，从服务器接收到加载进内存，主服务器将缓冲区的写命令发送给从服务器执行，执行完成，主从同步完成。

    主从同步完成后，当主服务器执行写命令后会进行命令传播，将命令发送给从服务器执行。

    过程断线后恢复重新同步的实现：
    进行命令传播时主从复制的双方都会记录偏移量，重新恢复会基于偏移量去恢复。如果恢复后从服务器的偏移量在
    主服务器的复制积压缓冲区内，则只需要将偏移量开始之后的命令发送执行即可，否则需要进行完整的同步。

19、redis哨兵机制
    sentinel监控主服务和从服务器，当主服务进入下线状态，从服务器的复制操作会被中止，sentinel会察觉到主服务器已经
    下线，当下线超过设置的时间上限,sentinel就会开始故障转移。
    sentinel会挑选一个从服务器作为主服务器，并且向其他从服务器发送新的复制命令，让他们成为新的主服务器的从服务器，并开始复制。
    还会继续监视已经下线的主服务器，当他再次上线时，将会成为新主服务器的从服务器。

    主观下线：当主服务器是一段时间内都没有有效回复时会被认为是主观下线。
    当有足够多数量的sentinel认为主服务器已经主观下线，则认为已经客观下线。

    客观下线就会开始故障转移：
    先选出一个领头的sentinel来执行故障转移。
    有某个sentinel被半数sentinel设置为局部领头，那就会变成领头sentinel.
    1、选择新的主服务器：根据优先级和复制偏移量排序
    2、向其他从服务器发送命令，让他们成为新的主服务器的从服务器。
    3、旧主服务器重新上线执行slaveof成为从服务器。

20、redis集群原理
    通过CLUSTER MEET 来创建集群
    Cluster state 结构中记录集群情况，集群中节点信息，槽的指派信息
    可以通过命令给集群节点指派槽
    执行命令时先判断槽点是不是在该节点，如果在就执行，不再就返回MOVED，并转向正确的节点重新发送命令。
    访问某个KEY，如果正在迁移中就会返回ask,引导到正确节点去访问。
21、redis发布订阅原理
publish subscribe psubscribe
订阅的本质就是一个字典表，key是订阅的频道，value是订阅的客户端。



